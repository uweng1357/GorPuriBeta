"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotenv";
exports.ids = ["vendor-chunks/dotenv"];
exports.modules = {

/***/ "(rsc)/./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst packageJson = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/dotenv/package.json\");\nconst version = packageJson.version;\n// Array of tips to display randomly\nconst TIPS = [\n    \"\\uD83D\\uDD10 encrypt with Dotenvx: https://dotenvx.com\",\n    \"\\uD83D\\uDD10 prevent committing .env to code: https://dotenvx.com/precommit\",\n    \"\\uD83D\\uDD10 prevent building .env in docker: https://dotenvx.com/prebuild\",\n    \"\\uD83D\\uDCE1 observe env with Radar: https://dotenvx.com/radar\",\n    \"\\uD83D\\uDCE1 auto-backup env with Radar: https://dotenvx.com/radar\",\n    \"\\uD83D\\uDCE1 version env with Radar: https://dotenvx.com/radar\",\n    \"\\uD83D\\uDEE0️  run anywhere with `dotenvx run -- yourcommand`\",\n    \"⚙️  specify custom .env file path with { path: '/custom/path/.env' }\",\n    \"⚙️  enable debug logging with { debug: true }\",\n    \"⚙️  override existing env vars with { override: true }\",\n    \"⚙️  suppress all logs with { quiet: true }\",\n    \"⚙️  write to custom object with { processEnv: myObject }\",\n    \"⚙️  load multiple .env files with { path: ['.env.local', '.env'] }\"\n];\n// Get a random tip from the tips array\nfunction _getRandomTip() {\n    return TIPS[Math.floor(Math.random() * TIPS.length)];\n}\nfunction parseBoolean(value) {\n    if (typeof value === \"string\") {\n        return ![\n            \"false\",\n            \"0\",\n            \"no\",\n            \"off\",\n            \"\"\n        ].includes(value.toLowerCase());\n    }\n    return Boolean(value);\n}\nfunction supportsAnsi() {\n    return process.stdout.isTTY // && process.env.TERM !== 'dumb'\n    ;\n}\nfunction dim(text) {\n    return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text;\n}\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n// Parse src into an Object\nfunction parse(src) {\n    const obj = {};\n    // Convert buffer to string\n    let lines = src.toString();\n    // Convert line breaks to same format\n    lines = lines.replace(/\\r\\n?/mg, \"\\n\");\n    let match;\n    while((match = LINE.exec(lines)) != null){\n        const key = match[1];\n        // Default undefined or null to empty string\n        let value = match[2] || \"\";\n        // Remove whitespace\n        value = value.trim();\n        // Check if double quoted\n        const maybeQuote = value[0];\n        // Remove surrounding quotes\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, \"$2\");\n        // Expand newlines if double quoted\n        if (maybeQuote === '\"') {\n            value = value.replace(/\\\\n/g, \"\\n\");\n            value = value.replace(/\\\\r/g, \"\\r\");\n        }\n        // Add to object\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _parseVault(options) {\n    options = options || {};\n    const vaultPath = _vaultPath(options);\n    options.path = vaultPath // parse .env.vault\n    ;\n    const result = DotenvModule.configDotenv(options);\n    if (!result.parsed) {\n        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);\n        err.code = \"MISSING_DATA\";\n        throw err;\n    }\n    // handle scenario for comma separated keys - for use with key rotation\n    // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n    const keys = _dotenvKey(options).split(\",\");\n    const length = keys.length;\n    let decrypted;\n    for(let i = 0; i < length; i++){\n        try {\n            // Get full key\n            const key = keys[i].trim();\n            // Get instructions for decrypt\n            const attrs = _instructions(result, key);\n            // Decrypt\n            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n            break;\n        } catch (error) {\n            // last key\n            if (i + 1 >= length) {\n                throw error;\n            }\n        // try next key\n        }\n    }\n    // Parse decrypted .env string\n    return DotenvModule.parse(decrypted);\n}\nfunction _warn(message) {\n    console.error(`[dotenv@${version}][WARN] ${message}`);\n}\nfunction _debug(message) {\n    console.log(`[dotenv@${version}][DEBUG] ${message}`);\n}\nfunction _log(message) {\n    console.log(`[dotenv@${version}] ${message}`);\n}\nfunction _dotenvKey(options) {\n    // prioritize developer directly setting options.DOTENV_KEY\n    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n        return options.DOTENV_KEY;\n    }\n    // secondary infra already contains a DOTENV_KEY environment variable\n    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n        return process.env.DOTENV_KEY;\n    }\n    // fallback to empty string\n    return \"\";\n}\nfunction _instructions(result, dotenvKey) {\n    // Parse DOTENV_KEY. Format is a URI\n    let uri;\n    try {\n        uri = new URL(dotenvKey);\n    } catch (error) {\n        if (error.code === \"ERR_INVALID_URL\") {\n            const err = new Error(\"INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development\");\n            err.code = \"INVALID_DOTENV_KEY\";\n            throw err;\n        }\n        throw error;\n    }\n    // Get decrypt key\n    const key = uri.password;\n    if (!key) {\n        const err = new Error(\"INVALID_DOTENV_KEY: Missing key part\");\n        err.code = \"INVALID_DOTENV_KEY\";\n        throw err;\n    }\n    // Get environment\n    const environment = uri.searchParams.get(\"environment\");\n    if (!environment) {\n        const err = new Error(\"INVALID_DOTENV_KEY: Missing environment part\");\n        err.code = \"INVALID_DOTENV_KEY\";\n        throw err;\n    }\n    // Get ciphertext payload\n    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;\n    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n    ;\n    if (!ciphertext) {\n        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);\n        err.code = \"NOT_FOUND_DOTENV_ENVIRONMENT\";\n        throw err;\n    }\n    return {\n        ciphertext,\n        key\n    };\n}\nfunction _vaultPath(options) {\n    let possibleVaultPath = null;\n    if (options && options.path && options.path.length > 0) {\n        if (Array.isArray(options.path)) {\n            for (const filepath of options.path){\n                if (fs.existsSync(filepath)) {\n                    possibleVaultPath = filepath.endsWith(\".vault\") ? filepath : `${filepath}.vault`;\n                }\n            }\n        } else {\n            possibleVaultPath = options.path.endsWith(\".vault\") ? options.path : `${options.path}.vault`;\n        }\n    } else {\n        possibleVaultPath = path.resolve(process.cwd(), \".env.vault\");\n    }\n    if (fs.existsSync(possibleVaultPath)) {\n        return possibleVaultPath;\n    }\n    return null;\n}\nfunction _resolveHome(envPath) {\n    return envPath[0] === \"~\" ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n    const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);\n    const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);\n    if (debug || !quiet) {\n        _log(\"Loading env from encrypted .env.vault\");\n    }\n    const parsed = DotenvModule._parseVault(options);\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsed, options);\n    return {\n        parsed\n    };\n}\nfunction configDotenv(options) {\n    const dotenvPath = path.resolve(process.cwd(), \".env\");\n    let encoding = \"utf8\";\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);\n    let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);\n    if (options && options.encoding) {\n        encoding = options.encoding;\n    } else {\n        if (debug) {\n            _debug(\"No encoding is specified. UTF-8 is used by default\");\n        }\n    }\n    let optionPaths = [\n        dotenvPath\n    ] // default, look for .env\n    ;\n    if (options && options.path) {\n        if (!Array.isArray(options.path)) {\n            optionPaths = [\n                _resolveHome(options.path)\n            ];\n        } else {\n            optionPaths = [] // reset default\n            ;\n            for (const filepath of options.path){\n                optionPaths.push(_resolveHome(filepath));\n            }\n        }\n    }\n    // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n    // parsed data, we will combine it with process.env (or options.processEnv if provided).\n    let lastError;\n    const parsedAll = {};\n    for (const path of optionPaths){\n        try {\n            // Specifying an encoding returns a string instead of a buffer\n            const parsed = DotenvModule.parse(fs.readFileSync(path, {\n                encoding\n            }));\n            DotenvModule.populate(parsedAll, parsed, options);\n        } catch (e) {\n            if (debug) {\n                _debug(`Failed to load ${path} ${e.message}`);\n            }\n            lastError = e;\n        }\n    }\n    const populated = DotenvModule.populate(processEnv, parsedAll, options);\n    // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n    debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);\n    quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);\n    if (debug || !quiet) {\n        const keysCount = Object.keys(populated).length;\n        const shortPaths = [];\n        for (const filePath of optionPaths){\n            try {\n                const relative = path.relative(process.cwd(), filePath);\n                shortPaths.push(relative);\n            } catch (e) {\n                if (debug) {\n                    _debug(`Failed to load ${filePath} ${e.message}`);\n                }\n                lastError = e;\n            }\n        }\n        _log(`injecting env (${keysCount}) from ${shortPaths.join(\",\")} ${dim(`-- tip: ${_getRandomTip()}`)}`);\n    }\n    if (lastError) {\n        return {\n            parsed: parsedAll,\n            error: lastError\n        };\n    } else {\n        return {\n            parsed: parsedAll\n        };\n    }\n}\n// Populates process.env from .env file\nfunction config(options) {\n    // fallback to original dotenv if DOTENV_KEY is not set\n    if (_dotenvKey(options).length === 0) {\n        return DotenvModule.configDotenv(options);\n    }\n    const vaultPath = _vaultPath(options);\n    // dotenvKey exists but .env.vault file does not exist\n    if (!vaultPath) {\n        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);\n        return DotenvModule.configDotenv(options);\n    }\n    return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n    const key = Buffer.from(keyStr.slice(-64), \"hex\");\n    let ciphertext = Buffer.from(encrypted, \"base64\");\n    const nonce = ciphertext.subarray(0, 12);\n    const authTag = ciphertext.subarray(-16);\n    ciphertext = ciphertext.subarray(12, -16);\n    try {\n        const aesgcm = crypto.createDecipheriv(\"aes-256-gcm\", key, nonce);\n        aesgcm.setAuthTag(authTag);\n        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;\n    } catch (error) {\n        const isRange = error instanceof RangeError;\n        const invalidKeyLength = error.message === \"Invalid key length\";\n        const decryptionFailed = error.message === \"Unsupported state or unable to authenticate data\";\n        if (isRange || invalidKeyLength) {\n            const err = new Error(\"INVALID_DOTENV_KEY: It must be 64 characters long (or more)\");\n            err.code = \"INVALID_DOTENV_KEY\";\n            throw err;\n        } else if (decryptionFailed) {\n            const err = new Error(\"DECRYPTION_FAILED: Please check your DOTENV_KEY\");\n            err.code = \"DECRYPTION_FAILED\";\n            throw err;\n        } else {\n            throw error;\n        }\n    }\n}\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed, options = {}) {\n    const debug = Boolean(options && options.debug);\n    const override = Boolean(options && options.override);\n    const populated = {};\n    if (typeof parsed !== \"object\") {\n        const err = new Error(\"OBJECT_REQUIRED: Please check the processEnv argument being passed to populate\");\n        err.code = \"OBJECT_REQUIRED\";\n        throw err;\n    }\n    // Set process.env\n    for (const key of Object.keys(parsed)){\n        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n            if (override === true) {\n                processEnv[key] = parsed[key];\n                populated[key] = parsed[key];\n            }\n            if (debug) {\n                if (override === true) {\n                    _debug(`\"${key}\" is already defined and WAS overwritten`);\n                } else {\n                    _debug(`\"${key}\" is already defined and was NOT overwritten`);\n                }\n            }\n        } else {\n            processEnv[key] = parsed[key];\n            populated[key] = parsed[key];\n        }\n    }\n    return populated;\n}\nconst DotenvModule = {\n    configDotenv,\n    _configVault,\n    _parseVault,\n    config,\n    decrypt,\n    parse,\n    populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzlCO1lBRUEsSUFBSXVELE9BQU87Z0JBQ1QsSUFBSXFDLGFBQWEsTUFBTTtvQkFDckJqRSxPQUFPLENBQUMsQ0FBQyxFQUFFM0IsSUFBSSx3Q0FBd0MsQ0FBQztnQkFDMUQsT0FBTztvQkFDTDJCLE9BQU8sQ0FBQyxDQUFDLEVBQUUzQixJQUFJLDRDQUE0QyxDQUFDO2dCQUM5RDtZQUNGO1FBQ0YsT0FBTztZQUNMMkQsVUFBVSxDQUFDM0QsSUFBSSxHQUFHVSxNQUFNLENBQUNWLElBQUk7WUFDN0JxRSxTQUFTLENBQUNyRSxJQUFJLEdBQUdVLE1BQU0sQ0FBQ1YsSUFBSTtRQUM5QjtJQUNGO0lBRUEsT0FBT3FFO0FBQ1Q7QUFFQSxNQUFNN0QsZUFBZTtJQUNuQkM7SUFDQTZDO0lBQ0FuRDtJQUNBd0U7SUFDQXREO0lBQ0E3QjtJQUNBb0U7QUFDRjtBQUVBb0MsMkJBQTJCLEdBQUd4RixhQUFhQyxZQUFZO0FBQ3ZEdUYsMkJBQTJCLEdBQUd4RixhQUFhOEMsWUFBWTtBQUN2RDBDLDBCQUEwQixHQUFHeEYsYUFBYUwsV0FBVztBQUNyRDZGLHFCQUFxQixHQUFHeEYsYUFBYW1FLE1BQU07QUFDM0NxQixzQkFBc0IsR0FBR3hGLGFBQWFhLE9BQU87QUFDN0MyRSxvQkFBb0IsR0FBR3hGLGFBQWFoQixLQUFLO0FBQ3pDd0csdUJBQXVCLEdBQUd4RixhQUFhb0QsUUFBUTtBQUUvQ29DLE9BQU9DLE9BQU8sR0FBR3pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvcnQtcmVzZXJ2YXRpb24vLi9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzPzJkODQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG5jb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbmNvbnN0IHZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbi8vIEFycmF5IG9mIHRpcHMgdG8gZGlzcGxheSByYW5kb21seVxuY29uc3QgVElQUyA9IFtcbiAgJ/CflJAgZW5jcnlwdCB3aXRoIERvdGVudng6IGh0dHBzOi8vZG90ZW52eC5jb20nLFxuICAn8J+UkCBwcmV2ZW50IGNvbW1pdHRpbmcgLmVudiB0byBjb2RlOiBodHRwczovL2RvdGVudnguY29tL3ByZWNvbW1pdCcsXG4gICfwn5SQIHByZXZlbnQgYnVpbGRpbmcgLmVudiBpbiBkb2NrZXI6IGh0dHBzOi8vZG90ZW52eC5jb20vcHJlYnVpbGQnLFxuICAn8J+ToSBvYnNlcnZlIGVudiB3aXRoIFJhZGFyOiBodHRwczovL2RvdGVudnguY29tL3JhZGFyJyxcbiAgJ/Cfk6EgYXV0by1iYWNrdXAgZW52IHdpdGggUmFkYXI6IGh0dHBzOi8vZG90ZW52eC5jb20vcmFkYXInLFxuICAn8J+ToSB2ZXJzaW9uIGVudiB3aXRoIFJhZGFyOiBodHRwczovL2RvdGVudnguY29tL3JhZGFyJyxcbiAgJ/Cfm6DvuI8gIHJ1biBhbnl3aGVyZSB3aXRoIGBkb3RlbnZ4IHJ1biAtLSB5b3VyY29tbWFuZGAnLFxuICAn4pqZ77iPICBzcGVjaWZ5IGN1c3RvbSAuZW52IGZpbGUgcGF0aCB3aXRoIHsgcGF0aDogXFwnL2N1c3RvbS9wYXRoLy5lbnZcXCcgfScsXG4gICfimpnvuI8gIGVuYWJsZSBkZWJ1ZyBsb2dnaW5nIHdpdGggeyBkZWJ1ZzogdHJ1ZSB9JyxcbiAgJ+Kame+4jyAgb3ZlcnJpZGUgZXhpc3RpbmcgZW52IHZhcnMgd2l0aCB7IG92ZXJyaWRlOiB0cnVlIH0nLFxuICAn4pqZ77iPICBzdXBwcmVzcyBhbGwgbG9ncyB3aXRoIHsgcXVpZXQ6IHRydWUgfScsXG4gICfimpnvuI8gIHdyaXRlIHRvIGN1c3RvbSBvYmplY3Qgd2l0aCB7IHByb2Nlc3NFbnY6IG15T2JqZWN0IH0nLFxuICAn4pqZ77iPICBsb2FkIG11bHRpcGxlIC5lbnYgZmlsZXMgd2l0aCB7IHBhdGg6IFtcXCcuZW52LmxvY2FsXFwnLCBcXCcuZW52XFwnXSB9J1xuXVxuXG4vLyBHZXQgYSByYW5kb20gdGlwIGZyb20gdGhlIHRpcHMgYXJyYXlcbmZ1bmN0aW9uIF9nZXRSYW5kb21UaXAgKCkge1xuICByZXR1cm4gVElQU1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBUSVBTLmxlbmd0aCldXG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9vbGVhbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gIVsnZmFsc2UnLCAnMCcsICdubycsICdvZmYnLCAnJ10uaW5jbHVkZXModmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgfVxuICByZXR1cm4gQm9vbGVhbih2YWx1ZSlcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNBbnNpICgpIHtcbiAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0LmlzVFRZIC8vICYmIHByb2Nlc3MuZW52LlRFUk0gIT09ICdkdW1iJ1xufVxuXG5mdW5jdGlvbiBkaW0gKHRleHQpIHtcbiAgcmV0dXJuIHN1cHBvcnRzQW5zaSgpID8gYFxceDFiWzJtJHt0ZXh0fVxceDFiWzBtYCA6IHRleHRcbn1cblxuY29uc3QgTElORSA9IC8oPzpefF4pXFxzKig/OmV4cG9ydFxccyspPyhbXFx3Li1dKykoPzpcXHMqPVxccyo/fDpcXHMrPykoXFxzKicoPzpcXFxcJ3xbXiddKSonfFxccypcIig/OlxcXFxcInxbXlwiXSkqXCJ8XFxzKmAoPzpcXFxcYHxbXmBdKSpgfFteI1xcclxcbl0rKT9cXHMqKD86Iy4qKT8oPzokfCQpL21nXG5cbi8vIFBhcnNlIHNyYyBpbnRvIGFuIE9iamVjdFxuZnVuY3Rpb24gcGFyc2UgKHNyYykge1xuICBjb25zdCBvYmogPSB7fVxuXG4gIC8vIENvbnZlcnQgYnVmZmVyIHRvIHN0cmluZ1xuICBsZXQgbGluZXMgPSBzcmMudG9TdHJpbmcoKVxuXG4gIC8vIENvbnZlcnQgbGluZSBicmVha3MgdG8gc2FtZSBmb3JtYXRcbiAgbGluZXMgPSBsaW5lcy5yZXBsYWNlKC9cXHJcXG4/L21nLCAnXFxuJylcblxuICBsZXQgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IExJTkUuZXhlYyhsaW5lcykpICE9IG51bGwpIHtcbiAgICBjb25zdCBrZXkgPSBtYXRjaFsxXVxuXG4gICAgLy8gRGVmYXVsdCB1bmRlZmluZWQgb3IgbnVsbCB0byBlbXB0eSBzdHJpbmdcbiAgICBsZXQgdmFsdWUgPSAobWF0Y2hbMl0gfHwgJycpXG5cbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICAvLyBDaGVjayBpZiBkb3VibGUgcXVvdGVkXG4gICAgY29uc3QgbWF5YmVRdW90ZSA9IHZhbHVlWzBdXG5cbiAgICAvLyBSZW1vdmUgc3Vycm91bmRpbmcgcXVvdGVzXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFsnXCJgXSkoW1xcc1xcU10qKVxcMSQvbWcsICckMicpXG5cbiAgICAvLyBFeHBhbmQgbmV3bGluZXMgaWYgZG91YmxlIHF1b3RlZFxuICAgIGlmIChtYXliZVF1b3RlID09PSAnXCInKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcci9nLCAnXFxyJylcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gb2JqZWN0XG4gICAgb2JqW2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBfcGFyc2VWYXVsdCAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGNvbnN0IHZhdWx0UGF0aCA9IF92YXVsdFBhdGgob3B0aW9ucylcbiAgb3B0aW9ucy5wYXRoID0gdmF1bHRQYXRoIC8vIHBhcnNlIC5lbnYudmF1bHRcbiAgY29uc3QgcmVzdWx0ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICBpZiAoIXJlc3VsdC5wYXJzZWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE1JU1NJTkdfREFUQTogQ2Fubm90IHBhcnNlICR7dmF1bHRQYXRofSBmb3IgYW4gdW5rbm93biByZWFzb25gKVxuICAgIGVyci5jb2RlID0gJ01JU1NJTkdfREFUQSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIGhhbmRsZSBzY2VuYXJpbyBmb3IgY29tbWEgc2VwYXJhdGVkIGtleXMgLSBmb3IgdXNlIHdpdGgga2V5IHJvdGF0aW9uXG4gIC8vIGV4YW1wbGU6IERPVEVOVl9LRVk9XCJkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kLGRvdGVudjovLzprZXlfNzg5MEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PXByb2RcIlxuICBjb25zdCBrZXlzID0gX2RvdGVudktleShvcHRpb25zKS5zcGxpdCgnLCcpXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cbiAgbGV0IGRlY3J5cHRlZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBmdWxsIGtleVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXS50cmltKClcblxuICAgICAgLy8gR2V0IGluc3RydWN0aW9ucyBmb3IgZGVjcnlwdFxuICAgICAgY29uc3QgYXR0cnMgPSBfaW5zdHJ1Y3Rpb25zKHJlc3VsdCwga2V5KVxuXG4gICAgICAvLyBEZWNyeXB0XG4gICAgICBkZWNyeXB0ZWQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdChhdHRycy5jaXBoZXJ0ZXh0LCBhdHRycy5rZXkpXG5cbiAgICAgIGJyZWFrXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGxhc3Qga2V5XG4gICAgICBpZiAoaSArIDEgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICAvLyB0cnkgbmV4dCBrZXlcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBkZWNyeXB0ZWQgLmVudiBzdHJpbmdcbiAgcmV0dXJuIERvdGVudk1vZHVsZS5wYXJzZShkZWNyeXB0ZWQpXG59XG5cbmZ1bmN0aW9uIF93YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoYFtkb3RlbnZAJHt2ZXJzaW9ufV1bV0FSTl0gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9kZWJ1ZyAobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZyhgW2RvdGVudkAke3ZlcnNpb259XVtERUJVR10gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9sb2cgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV0gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9kb3RlbnZLZXkgKG9wdGlvbnMpIHtcbiAgLy8gcHJpb3JpdGl6ZSBkZXZlbG9wZXIgZGlyZWN0bHkgc2V0dGluZyBvcHRpb25zLkRPVEVOVl9LRVlcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ET1RFTlZfS0VZICYmIG9wdGlvbnMuRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gc2Vjb25kYXJ5IGluZnJhIGFscmVhZHkgY29udGFpbnMgYSBET1RFTlZfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGlmIChwcm9jZXNzLmVudi5ET1RFTlZfS0VZICYmIHByb2Nlc3MuZW52LkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZXG4gIH1cblxuICAvLyBmYWxsYmFjayB0byBlbXB0eSBzdHJpbmdcbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIF9pbnN0cnVjdGlvbnMgKHJlc3VsdCwgZG90ZW52S2V5KSB7XG4gIC8vIFBhcnNlIERPVEVOVl9LRVkuIEZvcm1hdCBpcyBhIFVSSVxuICBsZXQgdXJpXG4gIHRyeSB7XG4gICAgdXJpID0gbmV3IFVSTChkb3RlbnZLZXkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFUlJfSU5WQUxJRF9VUkwnKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogV3JvbmcgZm9ybWF0LiBNdXN0IGJlIGluIHZhbGlkIHVyaSBmb3JtYXQgbGlrZSBkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1kZXZlbG9wbWVudCcpXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgLy8gR2V0IGRlY3J5cHQga2V5XG4gIGNvbnN0IGtleSA9IHVyaS5wYXNzd29yZFxuICBpZiAoIWtleSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGtleSBwYXJ0JylcbiAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBHZXQgZW52aXJvbm1lbnRcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1cmkuc2VhcmNoUGFyYW1zLmdldCgnZW52aXJvbm1lbnQnKVxuICBpZiAoIWVudmlyb25tZW50KSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3NpbmcgZW52aXJvbm1lbnQgcGFydCcpXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gR2V0IGNpcGhlcnRleHQgcGF5bG9hZFxuICBjb25zdCBlbnZpcm9ubWVudEtleSA9IGBET1RFTlZfVkFVTFRfJHtlbnZpcm9ubWVudC50b1VwcGVyQ2FzZSgpfWBcbiAgY29uc3QgY2lwaGVydGV4dCA9IHJlc3VsdC5wYXJzZWRbZW52aXJvbm1lbnRLZXldIC8vIERPVEVOVl9WQVVMVF9QUk9EVUNUSU9OXG4gIGlmICghY2lwaGVydGV4dCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVDogQ2Fubm90IGxvY2F0ZSBlbnZpcm9ubWVudCAke2Vudmlyb25tZW50S2V5fSBpbiB5b3VyIC5lbnYudmF1bHQgZmlsZS5gKVxuICAgIGVyci5jb2RlID0gJ05PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICByZXR1cm4geyBjaXBoZXJ0ZXh0LCBrZXkgfVxufVxuXG5mdW5jdGlvbiBfdmF1bHRQYXRoIChvcHRpb25zKSB7XG4gIGxldCBwb3NzaWJsZVZhdWx0UGF0aCA9IG51bGxcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGggJiYgb3B0aW9ucy5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlcGF0aCkpIHtcbiAgICAgICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IGZpbGVwYXRoLmVuZHNXaXRoKCcudmF1bHQnKSA/IGZpbGVwYXRoIDogYCR7ZmlsZXBhdGh9LnZhdWx0YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3NpYmxlVmF1bHRQYXRoID0gb3B0aW9ucy5wYXRoLmVuZHNXaXRoKCcudmF1bHQnKSA/IG9wdGlvbnMucGF0aCA6IGAke29wdGlvbnMucGF0aH0udmF1bHRgXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvc3NpYmxlVmF1bHRQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICcuZW52LnZhdWx0JylcbiAgfVxuXG4gIGlmIChmcy5leGlzdHNTeW5jKHBvc3NpYmxlVmF1bHRQYXRoKSkge1xuICAgIHJldHVybiBwb3NzaWJsZVZhdWx0UGF0aFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVIb21lIChlbnZQYXRoKSB7XG4gIHJldHVybiBlbnZQYXRoWzBdID09PSAnficgPyBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBlbnZQYXRoLnNsaWNlKDEpKSA6IGVudlBhdGhcbn1cblxuZnVuY3Rpb24gX2NvbmZpZ1ZhdWx0IChvcHRpb25zKSB7XG4gIGNvbnN0IGRlYnVnID0gcGFyc2VCb29sZWFuKHByb2Nlc3MuZW52LkRPVEVOVl9DT05GSUdfREVCVUcgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZykpXG4gIGNvbnN0IHF1aWV0ID0gcGFyc2VCb29sZWFuKHByb2Nlc3MuZW52LkRPVEVOVl9DT05GSUdfUVVJRVQgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWlldCkpXG5cbiAgaWYgKGRlYnVnIHx8ICFxdWlldCkge1xuICAgIF9sb2coJ0xvYWRpbmcgZW52IGZyb20gZW5jcnlwdGVkIC5lbnYudmF1bHQnKVxuICB9XG5cbiAgY29uc3QgcGFyc2VkID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0KG9wdGlvbnMpXG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMpXG5cbiAgcmV0dXJuIHsgcGFyc2VkIH1cbn1cblxuZnVuY3Rpb24gY29uZmlnRG90ZW52IChvcHRpb25zKSB7XG4gIGNvbnN0IGRvdGVudlBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYnKVxuICBsZXQgZW5jb2RpbmcgPSAndXRmOCdcbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuICBsZXQgZGVidWcgPSBwYXJzZUJvb2xlYW4ocHJvY2Vzc0Vudi5ET1RFTlZfQ09ORklHX0RFQlVHIHx8IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpKVxuICBsZXQgcXVpZXQgPSBwYXJzZUJvb2xlYW4ocHJvY2Vzc0Vudi5ET1RFTlZfQ09ORklHX1FVSUVUIHx8IChvcHRpb25zICYmIG9wdGlvbnMucXVpZXQpKVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIF9kZWJ1ZygnTm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLiBVVEYtOCBpcyB1c2VkIGJ5IGRlZmF1bHQnKVxuICAgIH1cbiAgfVxuXG4gIGxldCBvcHRpb25QYXRocyA9IFtkb3RlbnZQYXRoXSAvLyBkZWZhdWx0LCBsb29rIGZvciAuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtfcmVzb2x2ZUhvbWUob3B0aW9ucy5wYXRoKV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbXSAvLyByZXNldCBkZWZhdWx0XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBvcHRpb25QYXRocy5wdXNoKF9yZXNvbHZlSG9tZShmaWxlcGF0aCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBhcnNlZCBkYXRhIGluIGEgdGVtcG9yYXJ5IG9iamVjdCAoYmVjYXVzZSB3ZSBuZWVkIHRvIHJldHVybiBpdCkuICBPbmNlIHdlIGhhdmUgdGhlIGZpbmFsXG4gIC8vIHBhcnNlZCBkYXRhLCB3ZSB3aWxsIGNvbWJpbmUgaXQgd2l0aCBwcm9jZXNzLmVudiAob3Igb3B0aW9ucy5wcm9jZXNzRW52IGlmIHByb3ZpZGVkKS5cbiAgbGV0IGxhc3RFcnJvclxuICBjb25zdCBwYXJzZWRBbGwgPSB7fVxuICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9uUGF0aHMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3BlY2lmeWluZyBhbiBlbmNvZGluZyByZXR1cm5zIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBidWZmZXJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZyB9KSlcblxuICAgICAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHBhcnNlZEFsbCwgcGFyc2VkLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBfZGVidWcoYEZhaWxlZCB0byBsb2FkICR7cGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICAgIGxhc3RFcnJvciA9IGVcbiAgICB9XG4gIH1cblxuICBjb25zdCBwb3B1bGF0ZWQgPSBEb3RlbnZNb2R1bGUucG9wdWxhdGUocHJvY2Vzc0VudiwgcGFyc2VkQWxsLCBvcHRpb25zKVxuXG4gIC8vIGhhbmRsZSB1c2VyIHNldHRpbmdzIERPVEVOVl9DT05GSUdfIG9wdGlvbnMgaW5zaWRlIC5lbnYgZmlsZShzKVxuICBkZWJ1ZyA9IHBhcnNlQm9vbGVhbihwcm9jZXNzRW52LkRPVEVOVl9DT05GSUdfREVCVUcgfHwgZGVidWcpXG4gIHF1aWV0ID0gcGFyc2VCb29sZWFuKHByb2Nlc3NFbnYuRE9URU5WX0NPTkZJR19RVUlFVCB8fCBxdWlldClcblxuICBpZiAoZGVidWcgfHwgIXF1aWV0KSB7XG4gICAgY29uc3Qga2V5c0NvdW50ID0gT2JqZWN0LmtleXMocG9wdWxhdGVkKS5sZW5ndGhcbiAgICBjb25zdCBzaG9ydFBhdGhzID0gW11cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIG9wdGlvblBhdGhzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgZmlsZVBhdGgpXG4gICAgICAgIHNob3J0UGF0aHMucHVzaChyZWxhdGl2ZSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgX2RlYnVnKGBGYWlsZWQgdG8gbG9hZCAke2ZpbGVQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgICAgIGxhc3RFcnJvciA9IGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbG9nKGBpbmplY3RpbmcgZW52ICgke2tleXNDb3VudH0pIGZyb20gJHtzaG9ydFBhdGhzLmpvaW4oJywnKX0gJHtkaW0oYC0tIHRpcDogJHtfZ2V0UmFuZG9tVGlwKCl9YCl9YClcbiAgfVxuXG4gIGlmIChsYXN0RXJyb3IpIHtcbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZEFsbCwgZXJyb3I6IGxhc3RFcnJvciB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgcGFyc2VkOiBwYXJzZWRBbGwgfVxuICB9XG59XG5cbi8vIFBvcHVsYXRlcyBwcm9jZXNzLmVudiBmcm9tIC5lbnYgZmlsZVxuZnVuY3Rpb24gY29uZmlnIChvcHRpb25zKSB7XG4gIC8vIGZhbGxiYWNrIHRvIG9yaWdpbmFsIGRvdGVudiBpZiBET1RFTlZfS0VZIGlzIG5vdCBzZXRcbiAgaWYgKF9kb3RlbnZLZXkob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIERvdGVudk1vZHVsZS5jb25maWdEb3RlbnYob3B0aW9ucylcbiAgfVxuXG4gIGNvbnN0IHZhdWx0UGF0aCA9IF92YXVsdFBhdGgob3B0aW9ucylcblxuICAvLyBkb3RlbnZLZXkgZXhpc3RzIGJ1dCAuZW52LnZhdWx0IGZpbGUgZG9lcyBub3QgZXhpc3RcbiAgaWYgKCF2YXVsdFBhdGgpIHtcbiAgICBfd2FybihgWW91IHNldCBET1RFTlZfS0VZIGJ1dCB5b3UgYXJlIG1pc3NpbmcgYSAuZW52LnZhdWx0IGZpbGUgYXQgJHt2YXVsdFBhdGh9LiBEaWQgeW91IGZvcmdldCB0byBidWlsZCBpdD9gKVxuXG4gICAgcmV0dXJuIERvdGVudk1vZHVsZS5jb25maWdEb3RlbnYob3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBEb3RlbnZNb2R1bGUuX2NvbmZpZ1ZhdWx0KG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGRlY3J5cHQgKGVuY3J5cHRlZCwga2V5U3RyKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKGtleVN0ci5zbGljZSgtNjQpLCAnaGV4JylcbiAgbGV0IGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWQsICdiYXNlNjQnKVxuXG4gIGNvbnN0IG5vbmNlID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAxMilcbiAgY29uc3QgYXV0aFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLTE2KVxuICBjaXBoZXJ0ZXh0ID0gY2lwaGVydGV4dC5zdWJhcnJheSgxMiwgLTE2KVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYWVzZ2NtID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0yNTYtZ2NtJywga2V5LCBub25jZSlcbiAgICBhZXNnY20uc2V0QXV0aFRhZyhhdXRoVGFnKVxuICAgIHJldHVybiBgJHthZXNnY20udXBkYXRlKGNpcGhlcnRleHQpfSR7YWVzZ2NtLmZpbmFsKCl9YFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGlzUmFuZ2UgPSBlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3JcbiAgICBjb25zdCBpbnZhbGlkS2V5TGVuZ3RoID0gZXJyb3IubWVzc2FnZSA9PT0gJ0ludmFsaWQga2V5IGxlbmd0aCdcbiAgICBjb25zdCBkZWNyeXB0aW9uRmFpbGVkID0gZXJyb3IubWVzc2FnZSA9PT0gJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YSdcblxuICAgIGlmIChpc1JhbmdlIHx8IGludmFsaWRLZXlMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBJdCBtdXN0IGJlIDY0IGNoYXJhY3RlcnMgbG9uZyAob3IgbW9yZSknKVxuICAgICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIGlmIChkZWNyeXB0aW9uRmFpbGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0RFQ1JZUFRJT05fRkFJTEVEOiBQbGVhc2UgY2hlY2sgeW91ciBET1RFTlZfS0VZJylcbiAgICAgIGVyci5jb2RlID0gJ0RFQ1JZUFRJT05fRkFJTEVEJ1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG5cbi8vIFBvcHVsYXRlIHByb2Nlc3MuZW52IHdpdGggcGFyc2VkIHZhbHVlc1xuZnVuY3Rpb24gcG9wdWxhdGUgKHByb2Nlc3NFbnYsIHBhcnNlZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGRlYnVnID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpXG4gIGNvbnN0IG92ZXJyaWRlID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMub3ZlcnJpZGUpXG4gIGNvbnN0IHBvcHVsYXRlZCA9IHt9XG5cbiAgaWYgKHR5cGVvZiBwYXJzZWQgIT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdPQkpFQ1RfUkVRVUlSRUQ6IFBsZWFzZSBjaGVjayB0aGUgcHJvY2Vzc0VudiBhcmd1bWVudCBiZWluZyBwYXNzZWQgdG8gcG9wdWxhdGUnKVxuICAgIGVyci5jb2RlID0gJ09CSkVDVF9SRVFVSVJFRCdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIFNldCBwcm9jZXNzLmVudlxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJzZWQpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzRW52LCBrZXkpKSB7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICAgICAgcHJvY2Vzc0VudltrZXldID0gcGFyc2VkW2tleV1cbiAgICAgICAgcG9wdWxhdGVkW2tleV0gPSBwYXJzZWRba2V5XVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3YXMgTk9UIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgICAgcG9wdWxhdGVkW2tleV0gPSBwYXJzZWRba2V5XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3B1bGF0ZWRcbn1cblxuY29uc3QgRG90ZW52TW9kdWxlID0ge1xuICBjb25maWdEb3RlbnYsXG4gIF9jb25maWdWYXVsdCxcbiAgX3BhcnNlVmF1bHQsXG4gIGNvbmZpZyxcbiAgZGVjcnlwdCxcbiAgcGFyc2UsXG4gIHBvcHVsYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbmZpZ0RvdGVudiA9IERvdGVudk1vZHVsZS5jb25maWdEb3RlbnZcbm1vZHVsZS5leHBvcnRzLl9jb25maWdWYXVsdCA9IERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHRcbm1vZHVsZS5leHBvcnRzLl9wYXJzZVZhdWx0ID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0XG5tb2R1bGUuZXhwb3J0cy5jb25maWcgPSBEb3RlbnZNb2R1bGUuY29uZmlnXG5tb2R1bGUuZXhwb3J0cy5kZWNyeXB0ID0gRG90ZW52TW9kdWxlLmRlY3J5cHRcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gRG90ZW52TW9kdWxlLnBhcnNlXG5tb2R1bGUuZXhwb3J0cy5wb3B1bGF0ZSA9IERvdGVudk1vZHVsZS5wb3B1bGF0ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvdGVudk1vZHVsZVxuIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInBhdGgiLCJvcyIsImNyeXB0byIsInBhY2thZ2VKc29uIiwidmVyc2lvbiIsIlRJUFMiLCJfZ2V0UmFuZG9tVGlwIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwicGFyc2VCb29sZWFuIiwidmFsdWUiLCJpbmNsdWRlcyIsInRvTG93ZXJDYXNlIiwiQm9vbGVhbiIsInN1cHBvcnRzQW5zaSIsInByb2Nlc3MiLCJzdGRvdXQiLCJpc1RUWSIsImRpbSIsInRleHQiLCJMSU5FIiwicGFyc2UiLCJzcmMiLCJvYmoiLCJsaW5lcyIsInRvU3RyaW5nIiwicmVwbGFjZSIsIm1hdGNoIiwiZXhlYyIsImtleSIsInRyaW0iLCJtYXliZVF1b3RlIiwiX3BhcnNlVmF1bHQiLCJvcHRpb25zIiwidmF1bHRQYXRoIiwiX3ZhdWx0UGF0aCIsInJlc3VsdCIsIkRvdGVudk1vZHVsZSIsImNvbmZpZ0RvdGVudiIsInBhcnNlZCIsImVyciIsIkVycm9yIiwiY29kZSIsImtleXMiLCJfZG90ZW52S2V5Iiwic3BsaXQiLCJkZWNyeXB0ZWQiLCJpIiwiYXR0cnMiLCJfaW5zdHJ1Y3Rpb25zIiwiZGVjcnlwdCIsImNpcGhlcnRleHQiLCJlcnJvciIsIl93YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJfZGVidWciLCJsb2ciLCJfbG9nIiwiRE9URU5WX0tFWSIsImVudiIsImRvdGVudktleSIsInVyaSIsIlVSTCIsInBhc3N3b3JkIiwiZW52aXJvbm1lbnQiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJlbnZpcm9ubWVudEtleSIsInRvVXBwZXJDYXNlIiwicG9zc2libGVWYXVsdFBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJmaWxlcGF0aCIsImV4aXN0c1N5bmMiLCJlbmRzV2l0aCIsInJlc29sdmUiLCJjd2QiLCJfcmVzb2x2ZUhvbWUiLCJlbnZQYXRoIiwiam9pbiIsImhvbWVkaXIiLCJzbGljZSIsIl9jb25maWdWYXVsdCIsImRlYnVnIiwiRE9URU5WX0NPTkZJR19ERUJVRyIsInF1aWV0IiwiRE9URU5WX0NPTkZJR19RVUlFVCIsInByb2Nlc3NFbnYiLCJwb3B1bGF0ZSIsImRvdGVudlBhdGgiLCJlbmNvZGluZyIsIm9wdGlvblBhdGhzIiwicHVzaCIsImxhc3RFcnJvciIsInBhcnNlZEFsbCIsInJlYWRGaWxlU3luYyIsImUiLCJwb3B1bGF0ZWQiLCJrZXlzQ291bnQiLCJPYmplY3QiLCJzaG9ydFBhdGhzIiwiZmlsZVBhdGgiLCJyZWxhdGl2ZSIsImNvbmZpZyIsImVuY3J5cHRlZCIsImtleVN0ciIsIkJ1ZmZlciIsImZyb20iLCJub25jZSIsInN1YmFycmF5IiwiYXV0aFRhZyIsImFlc2djbSIsImNyZWF0ZURlY2lwaGVyaXYiLCJzZXRBdXRoVGFnIiwidXBkYXRlIiwiZmluYWwiLCJpc1JhbmdlIiwiUmFuZ2VFcnJvciIsImludmFsaWRLZXlMZW5ndGgiLCJkZWNyeXB0aW9uRmFpbGVkIiwib3ZlcnJpZGUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dotenv/lib/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"dotenv","version":"17.2.2","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ })

};
;